---
layout: post
title:  "CA Notes UPC"
date:   2025-09-15 12:00:00 +0200
preview: "/images/ca/ca.png"
categories: post
permalink: post/CA
---

This are some of my notes for Computer Animation. 
<!-- end-abstract -->

<!-- index -->
* Do not remove this line (it will not be displayed)
{:toc}

{% bibliography_loader _bibliography/ao_references.bib %}

# Course Introduction
This course covers foundational and advanced topics in computer animation, starting with particle systems as basic animation objects and exploring their state, forces, and collision handling. You will learn how mass-spring models enable the simulation of deformable objects in one, two, and three dimensions. The curriculum includes particle-based fluid simulation (SPH), rigid body dynamics, and articulated chains, focusing on interactions between solids and deformables. Navigation techniques such as cell and portal graphs, path finding, and roadmaps are introduced. The course also addresses character animation through keyframing, skinning, motion capture, and motion graphs, and concludes with crowd simulation using social forces, rule-based models, cellular automata, and precomputed search trees.

# Particles Animation

A particle is a zero-dimensional (0D) object, meaning it has no spatial extent—only a position in space. At any time {% equation_inline t %}, its state is defined by its position {% equation_inline \mathbf{x}(t) %}, velocity {% equation_inline \mathbf{v}(t) %}, and mass {% equation_inline m %}. The forces {% equation_inline \mathbf{F}(t) %} acting on the particle determine its acceleration via Newton's second law: {% equation_inline \mathbf{a}(t) = \frac{\mathbf{F}(t)}{m} %}. The simulation advances by calculating a new step: using the acceleration to update the velocity ({% equation_inline \mathbf{v}(t + \Delta t) = \mathbf{v}(t) + \mathbf{a}(t)\Delta t %}), and then updating the position ({% equation_inline \mathbf{x}(t + \Delta t) = \mathbf{x}(t) + \mathbf{v}(t + \Delta t)\Delta t %}). This process is structured as a loop: **current state → integrator → predicted state → constraint solver → corrected state → update state**. Differential equations (ODEs) describe how the state evolves over time and are solved during the **integrator** step to predict the next state of the particle. For more details, see [ODE](https://youtu.be/p_di4Zn4wz4?si=V41GIw-AXTiGQjAH).

Ordinary Differential Equations (ODEs) are used in particle integrators to model how a particle's state (position and velocity) changes over time under the influence of forces. The general form, {% equation_inline \mathbf{X}' = f(\mathbf{X}, t) %}, describes the rate of change of the state vector {% equation_inline \mathbf{X} %} (which includes position and velocity) as a function of the current state and time. In animation, we typically solve initial value problems, starting from a known state and computing its evolution.

Instead of solving these equations analytically, we use numerical methods (integrators) to estimate the next state. For example, using Euler's method:

- Update position: {% equation_inline \mathbf{x}_{t+\Delta t} = \mathbf{x}_t + \Delta t \cdot \mathbf{v}_t %}
- Update velocity: {% equation_inline \mathbf{v}_{t+\Delta t} = \mathbf{v}_t + \Delta t \cdot \frac{\mathbf{F}_t}{m} %}

Here, {% equation_inline \mathbf{F}_t %} is the force at time {% equation_inline t %}, and {% equation_inline m %} is the mass. The integrator uses the current state and the ODE to predict the new position and velocity for the next time step, allowing the simulation to progress.

## Numerical Solvers

### Euler's method / Forward Euler
A simple, first-order method for solving ordinary differential equations (ODEs). It estimates the next value using the current value and its derivative.
- Formula: {% equation_inline \mathbf{X}_{t+\Delta t} = \mathbf{X}_t + \Delta t \cdot \mathbf{X}'_t %}

### Euler Solver
Implements Euler's method by stepping forward in time using the slope at the current point.
- Formula: {% equation_inline \mathbf{X}_{t+\Delta t} = \mathbf{X}_t + \Delta t \cdot f(t, \mathbf{X}_t) %}

### Midpoint Method
A second-order method that improves accuracy by estimating the slope at the midpoint of the interval.
- Formula: {% equation_inline \mathbf{X}_{t+\Delta t} = \mathbf{X}_t + \Delta t \cdot f\left(t + \frac{\Delta t}{2}, \mathbf{X}_t + \frac{\Delta t}{2} \cdot f(t, \mathbf{X}_t)\right) %}

### Runge-Kutta solver (RK2, Heun’s method, improved Euler, trapezoidal rule)
Second-order Runge-Kutta methods use multiple slope estimates to achieve better accuracy than Euler's method. Heun’s method and the trapezoidal rule are common RK2 variants.
- Formula:  
{% equation id="rk2" %}
k_1 = f(t, \mathbf{X}_t) \\

k_2 = f(t + \Delta t, \mathbf{X}_t + \Delta t \cdot k_1) \\

\mathbf{X}_{t+\Delta t} = \mathbf{X}_t + \frac{\Delta t}{2}(k_1 + k_2)

{% endequation %}

<!-- {% equation id="rk2" %}
\begin{align*}
k_1 &= f(t, \mathbf{X}_t) \\
k_2 &= f(t + \Delta t, \mathbf{X}_t + \Delta t \cdot k_1) \\
\mathbf{X}_{t+\Delta t} &= \mathbf{X}_t + \frac{\Delta t}{2}(k_1 + k_2)
\end{align*}
{% endequation %} -->

### Runge-Kutta solver (RK4)
A widely used fourth-order method that calculates four slope estimates per step, providing high accuracy for solving ODEs.
- Formula:  
  {% equation id="rk4" %}
    k_1 = f(t, \mathbf{X}_t) \\
    k_2 = f\left(t + \frac{\Delta t}{2}, \mathbf{X}_t + \frac{\Delta t}{2} k_1\right) \\
    k_3 = f\left(t + \frac{\Delta t}{2}, \mathbf{X}_t + \frac{\Delta t}{2} k_2\right) \\
    k_4 = f(t + \Delta t, \mathbf{X}_t + \Delta t k_3) \\
    \mathbf{X}_{t+\Delta t} = \mathbf{X}_t + \frac{\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)
  {% endequation %}

  <!-- {% equation_inline
    \begin{align*}
    k_1 &= f(t, \mathbf{X}_t) \\
    k_2 &= f\left(t + \frac{\Delta t}{2}, \mathbf{X}_t + \frac{\Delta t}{2} k_1\right) \\
    k_3 &= f\left(t + \frac{\Delta t}{2}, \mathbf{X}_t + \frac{\Delta t}{2} k_2\right) \\
    k_4 &= f(t + \Delta t, \mathbf{X}_t + \Delta t k_3) \\
    \mathbf{X}_{t+\Delta t} &= \mathbf{X}_t + \frac{\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)
    \end{align*}
  %} -->

### Symplectic Euler (aka semi-implicit Euler)
A variant of Euler’s method designed for systems with conserved quantities (like energy), often used in physics simulations.
- Formula:  
{% equation id="symplectic" %}
  \mathbf{v}_{t+\Delta t} = \mathbf{v}_t + \Delta t \cdot \mathbf{a}_t \\
  \mathbf{x}_{t+\Delta t} = \mathbf{x}_t + \Delta t \cdot \mathbf{v}_{t+\Delta t}
{% endequation %}

### Verlet Solver
A method commonly used in molecular dynamics and physics simulations. It calculates positions based on previous positions and accelerations, offering good stability.
- Formula: 
{% equation %} 
\mathbf{x}_{t+\Delta t} = 2\mathbf{x}_t - \mathbf{x}_{t-\Delta t} + \Delta t^2 \cdot \mathbf{a}_t 
{% endequation %}

### Implicit Euler / Backward Euler
A stable, first-order method where the next value depends on the derivative at the next time step. Often used for stiff equations.
- Formula: 
{% equation %}
\mathbf{X}_{t+\Delta t} = \mathbf{X}_t + \Delta t \cdot f(t+\Delta t, \mathbf{X}_{t+\Delta t}) 
{% endequation %}

# Particles Collision
* Types
  * Discrete
  * Substepping
  * Continous

* Intersection tests:

|            | Point | Segment | Plane | Triangle | AABB | OBB | Sphere | Cylinder |
|------------|-------|---------|-------|----------|------|-----|--------|----------|
| **Point**      | ✓     | ✓       | ✓     | ✓        | ✓    | ✓   | ✓      | ✓        |
| **Segment**    | ✓     | ✓       | ✓     | ✓        | ✓    | ✓   | ✓      | ✓        |
| **Plane**      | ✓     | ✓       | ✓     | ✓        | ✓    | ✓   | ✓      | ✓        |
| **Triangle**   | ✓     | ✓       | ✓     | ✓        | ✓    | ✓   | ✓      | ✓        |
| **AABB**       | ✓     | ✓       | ✓     | ✓        | ✓    | ✓   | ✓      | ✓        |
| **OBB**        | ✓     | ✓       | ✓     | ✓        | ✓    | ✓   | ✓      | ✓        |
| **Sphere**     | ✓     | ✓       | ✓     | ✓        | ✓    | ✓   | ✓      | ✓        |
| **Cylinder**   | ✓     | ✓       | ✓     | ✓        | ✓    | ✓   | ✓      | ✓        |


*✓ indicates that intersection tests exist for the pair of primitives. The actual algorithms and complexity depend on the specific pair.*

[intersections calculation](https://www.realtimerendering.com/intersections.html)

# Mass Spring Systems


# Finite Elements Methods
When we are provided a mesh that represents a real world object such as a metalic cilinder, we intuitivelly understand that it is not empty but filled with the same material exposed in the surface. This omogenical piece of metal can be studied using `Continuum Mechanics`:

{% figure id="bending" size="0.5" caption="https://www.acs.psu.edu/drussell/Demos/Flexural-Bar/flexural-cividis.html" %}
https://www.acs.psu.edu/drussell/Demos/Flexural-Bar/Free-cividis-2.gif
{% endfigure%}

Forces such as pulling and pressing a material will result in different behaviors. If we hit a jelly, it will start trembling. Instead, if we hit a metal bar, the deformation and transmission of the energy will be complitelly different.

To study the deformation of a material subjected to some external forces, we use Hooke's law:

<!-- ## Hooke's law -->
{% equation id="Hook" %}
\frac{fn}{A} = E \frac{\Delta l}{l}
\\\quad\\
\sigma = E \varepsilon
{% endequation %}

{% equation id="Hook Matrix" %}
\sigma = 
\begin{bmatrix}
\sigma_{xx} & \sigma_{xy} & \sigma_{xz} \\
\sigma_{xy} & \sigma_{yy} & \sigma_{yz} \\
\sigma_{xz} & \sigma_{yz} & \sigma_{zz}
\end{bmatrix}
\\\quad\\
\varepsilon = 
\begin{bmatrix}
\varepsilon_{xx} & \varepsilon_{xy} & \varepsilon_{xz} \\
\varepsilon_{xy} & \varepsilon_{yy} & \varepsilon_{yz} \\
\varepsilon_{xz} & \varepsilon_{yz} & \varepsilon_{zz}
\end{bmatrix}
{% endequation %}
Where:
- {% equation_inline fn %}: Force normal to the cross-sectional area (N). It’s the force applied perpendicular to the area you’re considering in your calculations.
- {% equation_inline A %}: Cross-sectional area (m²)
- {% equation_inline E %}: Young's modulus (material stiffness/elasticity, Pa).{% equation_inline E %} is a 6x6 stiffness matrix (for 3D problems using Voigt notation).
- {% equation_inline \Delta l %}: Change in length (m)
- {% equation_inline l %}: Original length (m)
- {% equation_inline \sigma %}: Stress
- {% equation_inline \varepsilon %}: Strain

{% ref equation:Hook %} is used to calculate how much force (fn) is needed to deform an object (cilinder, rod,...). More specifically, we can use this theorem, for example, to know how much force we will need to extend a spring twice the size from its original state .

{% figure id="spring" caption="https://engineerexcel.com/hookes-law/" %}
https://engineerexcel.com/wp-content/uploads/2023/03/hookes-law.webp
{% endfigure %}


Hooke's law is a fundamental principle in continuum mechanics, stating that the deformation (strain) of an elastic material is proportional to the applied force (stress), up to a limit:
{% equation_inline \sigma = E\varepsilon %}
where {% equation_inline \sigma %} is stress, {% equation_inline E %} is Young's modulus (material stiffness), and {% equation_inline \varepsilon %} is strain.

Matrices {% equation_inline \sigma %} and {% equation_inline \varepsilon %} {% ref equation:Hook Matrix %} are simetricall. This allows us to use `voigt notation`:

{% equation id="voigt notation" %}
\begin{bmatrix}
\sigma_{xx} \\
\sigma_{yy} \\
\sigma_{zz} \\
\sigma_{yz} \\
\sigma_{xz} \\
\sigma_{xy}
\end{bmatrix} = \frac{E}{(1+\nu)(1-2\nu)}
\begin{bmatrix}
1-\nu & \nu & \nu & 0 & 0 & 0 \\
\nu & 1-\nu & \nu & 0 & 0 & 0 \\
\nu & \nu & 1-\nu & 0 & 0 & 0 \\
0 & 0 & 0 & \frac{1-2\nu}{2} & 0 & 0 \\
0 & 0 & 0 & 0 & \frac{1-2\nu}{2} & 0 \\
0 & 0 & 0 & 0 & 0 & \frac{1-2\nu}{2}
\end{bmatrix}
\begin{bmatrix}
\varepsilon_{xx} \\
\varepsilon_{yy} \\
\varepsilon_{zz} \\
\varepsilon_{yz} \\
\varepsilon_{xz} \\
\varepsilon_{xy}
\end{bmatrix}
{% endequation %}

Where {% equation_inline \nu \in [0, \frac{1}{2}) %} is Poisson's ratio.

If we know the original shape of the element and the deformed object, we can calulcate the strain {% equation_inline \varepsilon %} as the derivatives of the displacement field.

## Displacement Field

The displacement field {% equation_inline \mathbf{u}(\mathbf{x}) %} describes how much each point in the material moves from its original position:

{% equation id="displacement field" %}
\mathbf{u}(\mathbf{x}) = \mathbf{p}(\mathbf{x}) - \mathbf{x}
{% endequation %}

Where:
- {% equation_inline \mathbf{p}(\mathbf{x}) %}: Deformed position
- {% equation_inline \mathbf{x} %}: Original (reference) position
- {% equation_inline \mathbf{u}(\mathbf{x}) %}: Displacement vector

## Strain from Displacement
The strain tensor {% equation_inline \varepsilon %} quantifies the deformation of a material and can be computed from the displacement field. There are two main approaches depending on the magnitude of deformation:

## Cauchy's Linear Strain Tensor (Small Deformations)

For small deformations, we use the linearized (infinitesimal) strain tensor, also known as Cauchy's strain tensor:

{% equation id="cauchy strain" %}
\varepsilon_{ij} = \frac{1}{2}\left(\frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i}\right)
{% endequation %}

Where {% equation_inline i, j = x, y, z %} represent the spatial coordinates. This formulation assumes that displacements and their gradients are small, allowing us to neglect higher-order terms.

## Green's Nonlinear Strain Tensor (Large Deformations)

For large deformations where the linear assumption breaks down, we use Green's strain tensor (also called the Green-Lagrange strain tensor):

{% equation id="green strain" %}
E_{ij} = \frac{1}{2}\left(\frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} + \frac{\partial u_k}{\partial x_i}\frac{\partial u_k}{\partial x_j}\right)
{% endequation %}

Or in matrix form:

{% equation id="green strain matrix" %}
\mathbf{E} = \frac{1}{2}\left(\nabla \mathbf{u} + (\nabla \mathbf{u})^T + (\nabla \mathbf{u})^T \nabla \mathbf{u}\right)
{% endequation %}

The additional nonlinear term {% equation_inline \frac{\partial u_k}{\partial x_i}\frac{\partial u_k}{\partial x_j} %} accounts for geometric nonlinearities that arise when displacements are large. When displacements are small, this term becomes negligible, and Green's strain reduces to Cauchy's linear strain.

## Gradient of Displacement Field

The displacement gradient tensor {% equation_inline \nabla \mathbf{u} %} is a 3×3 matrix containing all first-order partial derivatives:

{% equation id="displacement gradient" %}
\nabla \mathbf{u} = 
\begin{bmatrix}
\frac{\partial u_x}{\partial x} & \frac{\partial u_x}{\partial y} & \frac{\partial u_x}{\partial z} \\[0.3em]
\frac{\partial u_y}{\partial x} & \frac{\partial u_y}{\partial y} & \frac{\partial u_y}{\partial z} \\[0.3em]
\frac{\partial u_z}{\partial x} & \frac{\partial u_z}{\partial y} & \frac{\partial u_z}{\partial z}
\end{bmatrix}
{% endequation %}

This gradient describes how the displacement changes in space and is fundamental for computing the strain tensor.



<!-- # Finite Elements
Finite elements are small, simple shapes (such as triangles, quadrilaterals, tetrahedra, or hexahedra) used to discretize a complex object or domain into manageable pieces. Each element represents a portion of the object, and together they form a mesh that approximates the geometry and physical properties of the whole.

## Continuum Mechanics and Hooke's Law

Continuum mechanics is the study of the mechanical behavior of materials modeled as continuous masses rather than discrete particles. It describes how materials deform, flow, or respond to forces. 

## Finite Element Methods (FEM)

Finite Element Methods are numerical techniques for solving problems in engineering and physics that involve complex geometries, boundary conditions, and material properties. FEM divides the domain into finite elements, formulates equations for each element based on physical laws (like Hooke's law), and assembles them into a global system to solve for unknowns such as displacement, stress, or temperature.


Lets say we have:


The stress and strain tensors above are symmetric matrices. This symmetry arises because the physical laws governing elastic materials ensure that shear stresses and strains are equal on opposing faces—meaning, for example, {% equation_inline \sigma_{xz} = \sigma_{zx} %} and {% equation_inline \varepsilon_{xz} = \varepsilon_{zx} %}. As a result, both the upper and lower triangles of the matrices mirror each other. This symmetry reflects the fact that the order of variables (such as _xz appearing in both the top right and lower left positions) is dictated by the underlying physics: the material's response to deformation is the same regardless of the direction in which the shear is applied. This property simplifies calculations and is fundamental to continuum mechanics and finite element analysis.




### Tensor Notation for Hooke's Law

In tensor notation, Hooke's law for linear elasticity is written as:
{% equation %}
\sigma_{ij} = E_{ijkl} \, \varepsilon_{kl}
{% endequation %}
where:
- {% equation_inline \sigma_{ij} %} is the stress tensor component (i, j = 1, 2, 3),
- {% equation_inline \varepsilon_{kl} %} is the strain tensor component (k, l = 1, 2, 3),
- {% equation_inline E_{ijkl} %} is the fourth-order elasticity (stiffness) tensor.

This formula expresses that each stress component depends linearly on all strain components, with the proportionality given by the material's stiffness tensor. The indices i, j, k, l run from 1 to 3, covering all spatial directions. For isotropic materials, the stiffness tensor has symmetries that greatly reduce the number of independent components.

### Voigt Notation

Voigt notation is a way to simplify tensor equations in elasticity by flattening the symmetric $3 \times 3$ stress and strain tensors into $6 \times 1$ column vectors. This makes the math easier to work with, especially for computer simulations and FEM.

- The stress tensor $\sigma$ and strain tensor $\varepsilon$ are written as vectors:
  $$(\sigma_{xx}, \sigma_{yy}, \sigma_{zz}, \sigma_{yz}, \sigma_{xz}, \sigma_{xy})^T$$
  $$(\varepsilon_{xx}, \varepsilon_{yy}, \varepsilon_{zz}, \varepsilon_{yz}, \varepsilon_{xz}, \varepsilon_{xy})^T$$
- The fourth-order stiffness tensor $E_{ijkl}$ is flattened into a $6 \times 6$ stiffness matrix $C$.
- The relationship becomes:
  $${\sigma} = C \varepsilon$$

For a general anisotropic material (properties differ in all directions), the $6 \times 6$ stiffness matrix can have up to 21 independent constants. For isotropic materials (same properties in all directions), only 2 independent constants are needed (Young's modulus $E$ and Poisson's ratio $\nu$).

**Summary:** Voigt notation makes it easier to work with stress, strain, and stiffness in 3D elasticity problems by converting tensors to vectors and matrices, reducing complexity and making FEM calculations more practical.

## Real-Life Example

FEM is widely used in game engines for simulating soft bodies, cloth, and deformable objects. For example, in scientific simulations, FEM is used to analyze stress and deformation in bridges, car crash simulations, and biomechanics. In games, Unreal Engine and Unity use FEM-based techniques for realistic cloth and soft body physics, enabling characters' clothing and flexible objects to move and deform naturally. -->

# Constrained Dynamics
# Position Based Dynamics

---
{% alert info %}
This are the second half notes of the course
{% endalert %}

---
# Rigid Bodies
While particles are limited to a position in phase space and velocity in phase space, rigid bodies possess a set of new properties for Translation and Rotation. In rigid bodies, the orientation of the object matters.

| Translation (linear) | Symbol / Formula | Rotation (angular) | Symbol / Formula | Notes |
|---|---|---|---|---|
| Position | x (or r) | Orientation | R (rotation matrix) or q (quaternion) | Position is a vector in R^3; <br/> orientation is a rotation describing body frame vs world frame. |
| Linear velocity | v = dx/dt | Angular velocity | ω (vector) | v is translational speed; <br/> ω is rotation axis × rate (radians/s). |
| Mass | m (scalar) | Inertia tensor | I (3×3 matrix, body or world frame) | Mass resists linear acceleration; <br/> inertia tensor resists angular acceleration and depends on mass distribution. |
| Linear momentum | p = m v | Angular momentum | L = I ω (or L = I·ω) | Momentum is conserved in absence of forces/torques. <br/> Note: L transforms with rotation if I is in body frame. |
| Force | F = dp/dt = m a | Torque (moment) | τ = dL/dt = I α + ω × (I ω) | Torque causes change in angular momentum; <br/> for body-frame I constant, use body equations with extra ω×(Iω) term. |

We establish a cordinate system for the rigid body, usually the classic XYZ space. 
The center of the object is based on the mass distributtion of the volume. We can estimate it however we wish (mean of all vertices, add weight to each vertex, ...)

After applying the corresponding transformations (translation, rotation, scale) we get the object in world coordinatesd. 
If you are familiarized in games, you will understand this as an asset (in local space) and instance (in global space).
We can mathematically explain this as:

Let r_0 ∈ R^3 be a point in the body (local) frame, x(t) ∈ R^3 the center-of-mass position in world coordinates, and R(t) ∈ R^{3×3} the rotation matrix from local to world. Then the world position r(t) is

{% equation %}
r(t)=R(t)\cdot r_0 + x(t).
{% endequation %}

Component form:
{% equation %}
r_i(t)=\sum_{j=1}^3 R_{ij}(t)\cdot r_{0,j} + x_i(t),\qquad i=1,2,3.
{% endequation %}

The action of R on the local basis vectors gives its columns. For the local x-axis {% equation_inline e_1=(1,0,0)^T %}:
{% equation %}
R(t)\cdot e_1 = \begin{bmatrix}R_{11}(t)\\[4pt]R_{21}(t)\\[4pt]R_{31}(t)\end{bmatrix},
{% endequation %}
so {% equation_inline R(t) = [u(t)\; v(t)\; w(t)] %}  where u,v,w are the world-space directions of the local x,y,z axes (the columns of R).

Inverse (recover local coordinates):
{% equation %}
r_0 = R(t)^\top\bigl(r(t)-x(t)\bigr)
{% endequation %}
since R(t) is orthogonal {% equation_inline R^\top = R^{-1} %}.

Equivalently using homogeneous coordinates:
{% equation %}
T(t)=\begin{bmatrix}R(t) & x(t)\\[4pt]0\;0\;0 & 1\end{bmatrix},\qquad
\begin{bmatrix}r(t)\\1\end{bmatrix}=T(t)\begin{bmatrix}r_0\\1\end{bmatrix}
{% endequation %}

## Linear velociry
since x(t) is thew position of the center of mass in world spave, x'(t) is the velocity of the center of mass in world spave

{% equation %}
v(t)=x'(t)
{% endequation %}

## Angular velociry
If we freeze the position of the center of mass in space, then any movement is due to the body spinning about some axis that passes through the center of mass.
Otherwise, the center of mas would itself be moving

We describe the spin as a vector w(f)

{% alert secondary %}
In the case of Linear position and linear velocity, they are related by:
{% equation %}
v(t) = \frac{d}{dt} x(t)
{% endequation %}

With the same idea, we can predict the new position of a point based on the angular change rate w(t):

{% equation %}
c'(t) = w(t) \times c(t)
{% endequation %}

{% endalert %}

As mentioned earlier, R(t) represents the axis of the rigid body at  time t.
The derivative of R(t) is the change rate from the previous axis to the new one.

We have the 3 axis of the system as e1, e2, e3:
{% equation id="body_axes" %}
e_1 = \begin{bmatrix} r_{xx} \\ r_{xy} \\ r_{xz} \end{bmatrix},\quad
e_2 = \begin{bmatrix} r_{yx} \\ r_{yy} \\ r_{yz} \end{bmatrix},\quad
e_3 = \begin{bmatrix} r_{zx} \\ r_{zy} \\ r_{zz} \end{bmatrix}
{% endequation %}

The derivative of the axis x can be obtained with vector w(t):
{% equation id="e1_derivative_vector" %}
\frac{d}{dt}\begin{bmatrix} r_{xx} \\ r_{xy} \\ r_{xz} \end{bmatrix}
= \boldsymbol{\omega}(t)\times\begin{bmatrix} r_{xx} \\ r_{xy} \\ r_{xz} \end{bmatrix}
{% endequation %}

In matricial form, we get that the full matrix of w(t) looks like:
{% equation id="e1_derivative_matrix" %}
\frac{d e_1}{dt} = [\boldsymbol{\omega}]_\times e_1,\qquad
[\boldsymbol{\omega}]_\times =
\begin{bmatrix}
0 & -\omega_z & \omega_y \\
\omega_z & 0 & -\omega_x \\
-\omega_y & \omega_x & 0
\end{bmatrix}
{% endequation %}

Finally, we get R'(t) (the derivative) as:
{% equation id="R_derivative" %}
R'(t) = w(t)*R(t)
{% endequation %}


To calculate the velocity at a single point we get:
{% equation id="R_derivative" %}
r_i'(t) = w \times (r_i(t)-x(t))+v(t)
{% endequation %}

## Mass and Inertia tensor

## Rigid Bodies Collision



---

# Articulated Motion Capture (MoCap) — Study Notes

Articulated MoCap models a system of **rigid bodies (links)** connected by **joints**, each joint introducing **degrees of freedom (DOF)** (e.g., rotations or translations).
Understanding motion involves two key processes: **Forward Kinematics (FK)** and **Inverse Kinematics (IK)**.

---

## Homogeneous Transformation Matrix

A **homogeneous matrix** {% equation_inline H %} combines **rotation** and **translation** into one 4×4 matrix, enabling easy chaining of transformations.

General form:
{% equation %}
H = T(\text{translation}) \times R(\text{rotation})
{% endequation %}

For articulated systems, transformations are often expressed **relative to successive local coordinate frames**.

Example composition:
{% equation %}
H = T_{XYZ} \times R_{XYZ} \times T_{IJK} \times R_{IJK}
{% endequation %}

Each term moves from one frame to another.

---

## Forward Kinematics (FK)

> **From joint angles → end-effector position**

### Concept

Given joint parameters (e.g. angles θ₁, θ₂, …) and link lengths (l₁, l₂, …), determine the **position and orientation** of the end-effector.

### Example: Planar 2-Link Arm

* Links of lengths {% equation_inline l_1, l_2 %}
* Joint angles {% equation_inline \theta_1, \theta_2  %}

Position of end-effector (geometric form):
{% equation %}
x = l_1 \cos(\theta_1) + l_2 \cos(\theta_1 + \theta_2)
{% endequation %}
{% equation %}
y = l_1 \sin(\theta_1) + l_2 \sin(\theta_1 + \theta_2)
{% endequation %}

### Matrix (algebraic) approach

For a 3-link planar manipulator:

{% equation %}
H = R_z(\theta_1) , T_x(l_1) , R_z(\theta_2) , T_x(l_2) , R_z(\theta_3) , T_x(l_3)
{% endequation %}

If you multiply ( H ) by the position vector ( [0, 0, 0, 1]^T ) of the end-effector (in its local frame),
the **last column of ( H )** gives its position in the base frame.

---

## Inverse Kinematics (IK)

> **From desired position → joint angles**

Given desired ([x, y]) (or ([x, y, z])), find {% equation_inline (\theta_1, \theta_2, ...) %}

### Non-uniqueness

* May have **two solutions** (“elbow up” / “elbow down”).
* Sometimes **no solution** (if target out of reach).

---
### 3.1 Geometric Solution (for planar 2-link)

The "geometric solution" is a closed-form, analytic method that uses simple geometry (triangle relations) to compute joint angles directly from a desired end-effector position. It does not require iterative solvers or Jacobians — instead it solves triangles formed by the links and the target point.

A "planar 2-link" manipulator is a simple arm with two rigid links connected by revolute joints that move in a plane. Link lengths are l_1 and l_2, joint angles are θ_1 (shoulder) and θ_2 (elbow), and the goal is to find θ_1, θ_2 given a target point (x,y) for the end-effector.

We use the Law of Cosines to relate the three sides of the triangle formed by the two links and the line from the base to the target:

{% equation %}
c^2 = a^2 + b^2 - 2ab \cos(C)
{% endequation %}

Step-by-step:
1. Compute the distance from the base to the target:
{% equation %}
r = \sqrt{x^2 + y^2}
{% endequation %}

2. Use the law of cosines to get the angle at the elbow (θ_2). This gives:
{% equation %}
\cos(\theta_2) = \frac{r^2 - l_1^2 - l_2^2}{2 l_1 l_2}
{% endequation %}

- Check reachability: the target is reachable only if the right-hand side lies in [-1, 1]. If outside, no real solution exists (target too far or too close).

3. Solve for θ_2:
{% equation %}
\theta_2 = \arccos\!\left(\frac{r^2 - l_1^2 - l_2^2}{2 l_1 l_2}\right)
{% endequation %}

- There are typically two valid solutions for θ_2 (elbow-up and elbow-down) corresponding to θ_2 and -θ_2 (or equivalently using ± for the sine term in the next step).

4. Compute θ_1 using geometry (angle to target minus the angle between l1 and the line to the wrist):
{% equation %}
\theta_1 = \arctan2(y, x) - \arctan2\!\bigl(l_2 \sin(\theta_2),\; l_1 + l_2 \cos(\theta_2)\bigr)
{% endequation %}

Notes:
- To obtain the alternate (elbow) configuration, use the alternate sign for sin(θ_2) in the θ_1 formula (or use θ_2' = -θ_2).

- This method returns direct (analytic) joint angles for the planar 2-link arm given (x,y); numerical methods are not needed unless additional constraints or redundancy exist.

- Handle degenerate cases {% equation_inline r = 0, r ≈ |l1±l2| %} carefully to avoid numerical instability.

---

### 3.2 Algebraic / Matrix Solution

Model FK as:
{% equation %}
H = R_y(r_1) , T_x(l_1) , R_z(r_2) , T_x(l_2) , R_z(r_3) , T_x(l_3)
{% endequation %}
Given a desired end-effector position ( W = [X, Y, Z, 1]^T ), solve numerically for ( r_1, r_2, r_3 ).

---

### 3.3 Numerical Solution (Newton’s Method)

**Goal:** Find ( \mathbf{r} ) such that ( f(\mathbf{r}) = W )

Jacobian ( J = \frac{\partial f}{\partial r} ) (matrix of partial derivatives)

Iterative update:
{% equation %}
J , \Delta r = W - f(r)
{% endequation %}
{% equation %}
r_{\text{new}} = r_{\text{old}} + \Delta r
{% endequation %}

* Works well if initial guess is close.
* Can **diverge** if not.
* Large movements → break into smaller steps:
{% equation %}
W_0 \rightarrow W_1 \rightarrow W_2 \rightarrow W_f
{% endequation %}

---

## The Jacobian

### Numerical Derivative

Column {% equation_inline i %} of {% equation_inline J %}:
{% equation %}
J_i \approx \frac{f(\theta_i + \Delta \theta_i) - f(\theta_i)}{\Delta \theta_i}
{% endequation %}

### Analytical Derivative

Use product rule — only the term involving the current DOF varies.

---

## Derivatives of Basic Transformations

### Derivative of Translation Matrix

Translation along {% equation_inline x %}:
{% equation %}
T_x(l) =
\begin{bmatrix}
1 & 0 & 0 & l \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
{% endequation %}

Derivative wrt {% equation_inline l %}:
{% equation %}
\frac{dT_x}{dl} =
\begin{bmatrix}
0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0
\end{bmatrix}
{% endequation %}

---

### Derivative of Rotation about z-axis

{% equation %}
R_z(\theta) =
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 & 0\\
\sin\theta &  \cos\theta & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
{% endequation %}

Derivative wrt {% equation_inline \theta %}:
{% equation %}
\frac{dR_z}{d\theta} =
\begin{bmatrix}
-\sin\theta & -\cos\theta & 0 & 0\\
\cos\theta & -\sin\theta & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0
\end{bmatrix}
{% endequation %}

---

## Summary Cheat Sheet

| Concept                | Maps                              | Method                             |
| ---------------------- | --------------------------------- | ---------------------------------- |
| **Forward Kinematics** | Angles → Position                 | Multiply transformations           |
| **Inverse Kinematics** | Position → Angles                 | Geometric, algebraic, or numerical |
| **Homogeneous Matrix** | Rotation + Translation            | 4×4 matrix                         |
| **Jacobian**           | Sensitivity of position to angles | Used in numerical IK               |
| **Newton’s Method**    | Iterative numerical solver        | Needs good initial guess           |

---


# Laboratory Sessions
## Integrators
## Forces
## Particle Systems
## Cloth

# Laboratory Sessions 2

